module Avram::Associations::Polymorphic
  macro polymorphic_belongs_to(type_declaration, autogenerated = false)

    {% assoc_name = type_declaration.var %}
    {% nilable = false %}

    {% if type_declaration.type.is_a?(Union) %}
      {% for type in type_declaration.type.types %}
        {% if type.is_a?(Path) %}
          {% nilable = true if type.names.first == "Nil" %}
        {% elsif type.is_a?(Union) %}
          {% nilable = true if type.types.any? { |item| item.names.first == "Nil" } %}
        {% end %}
      {% end %}
    {% end %}

    {% COLUMNS << {name: type_declaration.var + "_id", type: Int64, nilable: nilable.id, autogenerated: autogenerated} %}
    {% COLUMNS << {name: type_declaration.var + "_type", type: String, nilable: nilable.id, autogenerated: autogenerated} %}

    macro finished
      class SaveOperation
        before_save do
          {% if nilable %}
          validate_inclusion_of {{ type_declaration.var }}_type, in: {{type_declaration.type.types.map(&.stringify).push("").push(nil)}}
          {% else %}
          validate_required {{ type_declaration.var }}_type
          validate_required {{ type_declaration.var }}_id
          {% if type_declaration.type.is_a?(Union) %}
          validate_inclusion_of {{ type_declaration.var }}_type, in: {{type_declaration.type.types.map(&.stringify)}}
          {% else %}
          validate_inclusion_of {{ type_declaration.var }}_type, in: [{{type_declaration.type.id}}]
          {% end %}
          {% end %}
        end
      end
    end

    def {{assoc_name}} : {{type_declaration.type}}{% if nilable %}?{% end %}
    {% if nilable %}
      return nil if {{assoc_name}}_id.nil?
    {% end %}

    {% if type_declaration.type.is_a?(Union) %}
      case {{assoc_name}}_type
      {% for type in type_declaration.type.types %}
        {% if type.id != "Nil" %}
      when "{{type}}"
        if _{{ assoc_name }}_preloaded?
          @_preloaded_{{ assoc_name }}{% unless nilable %}.not_nil!{% end %}
        elsif lazy_load_enabled? || allow_lazy
          {{assoc_name}}_id.try do |lookup_id|
            {{type}}::BaseQuery.find(lookup_id)
          end
        else
          raise Avram::LazyLoadError.new {{ @type.name.stringify }}, {{ assoc_name.stringify }}
        end
        {% end %}
      {% end %}
      else
        raise "Unknown {{type_declaration.var}}: #{{{type_declaration.var}}_type}"
      end
    {% end %}
    end

    define_polymorphic_belongs_to_private_assoc_getter({{ type_declaration.var }}, {{type_declaration}}, {{nilable}})
    Avram::Associations.__define_public_preloaded_getters({{ type_declaration.var }}, {{type_declaration.type}}, {{nilable}})
    Avram::Associations.__define_preloaded_setter({{ type_declaration.var }}, {{type_declaration.type}})
    define_polymorphic_belongs_to_base_query({{ type_declaration.var }}, {{type_declaration}})
  end

  private macro define_polymorphic_belongs_to_private_assoc_getter(assoc_name, model, nilable)
    private def get_{{ assoc_name.id }}(allow_lazy : Bool = false) : {{ model.type }}{% if nilable %}?{% end %}
      if _{{ assoc_name }}_preloaded?
        @_preloaded_{{ assoc_name }}{% unless nilable %}.not_nil!{% end %}
      elsif lazy_load_enabled? || allow_lazy\
        {% if nilable %}
        {{ assoc_name }}_id.try do |value|
          case {{ assoc_name }}_type
          {% for type in model.type.types %}
            {% if type.id != "Nil" %}
            when "{{type}}"
              {{ type }}::BaseQuery.new.find(value)
            {% end %}
          {% end %}
          end
        end
        {% else %}
        case {{ assoc_name }}_type
        {% if model.type.is_a?(Union) %}
        {% for type in model.type.types %}
          {% if type.id != "Nil" %}
          when "{{type}}"
            {{ type }}::BaseQuery.new.find({{ assoc_name }}_id)
          {% end %}
        {% end %}
        {% else %}
          when "{{model.type}}"
            {{ model.type }}::BaseQuery.new.find({{ assoc_name }}_id)
        {% end %}
        {% if model.type.is_a?(Union) %}
          else
            {{ model.type.types.first }}::BaseQuery.new.find({{ assoc_name }}_id)
        {% else %}
          else
            {{ model.type.id }}::BaseQuery.new.find({{ assoc_name }}_id)
        {% end %}
        end
        {% end %}
      else
        raise Avram::LazyLoadError.new {{ @type.name.stringify }}, {{ assoc_name.stringify }}
      end
    end
  end

  private macro define_polymorphic_belongs_to_base_query(assoc_name, model)
    {% foreign_key = "#{assoc_name}_id".id %}
    {% foreign_type = "#{assoc_name}_type".id %}

    class BaseQuery < Avram::Query
      def preload_{{ assoc_name }}
      {% if model.type.is_a?(Union) %}
        {% for type in model.type.types %}
          {% if type.id != "Nil" %}
        preload_{{ assoc_name }}({{ type }}::BaseQuery.new, {{ type }})
          {% end %}
        {% end %}
      {% else %}
        preload_{{ assoc_name }}({{ model.type }}::BaseQuery.new, {{ model.type }})
      {% end %}
      end

      {% if model.type.is_a?(Union) %}
        {% return_type = model.type.types.map { |x| "#{x.id}::BaseQuery".id }.join(" | ").id %}
        {% primary_keys = model.type.types.map { |x| "#{x.id}::PrimaryKeyType".id }.join(" | ").id %}
      {% else %}
        {% return_type = model.type.id + "::BaseQuery" %}
        {% primary_keys = "#{model.type}::PrimaryKeyType".id %}
      {% end %}

      def preload_{{ assoc_name }}(preload_query : {{return_type}}, type_class : Avram::Model.class)
        add_preload do |records|
          ids = [] of {{primary_keys}}
          records.each do |record|
            record.{{ foreign_key }}.try do |id|
              ids << id if record.{{"#{assoc_name}_type".id}} == type_class.name
            end
          end
          {{ assoc_name }} = preload_query.dup.id.in(ids).results.group_by(&.id)
          records.each do |record|
            if (id = record.{{ foreign_key }}) && record.{{foreign_type}} == type_class.name
              record.__set_preloaded_{{ assoc_name }} {{ assoc_name }}[id]?.try(&.first?)
            elsif record.{{foreign_type}} == type_class.name
              record.__set_preloaded_{{ assoc_name }} nil
            end
          end
        end
        self
      end
    end
  end
end
