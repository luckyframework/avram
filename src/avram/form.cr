require "./validations"
require "./callbacks"
require "./nested_form"
require "./needy_initializer_and_save_methods"
require "./virtual"
require "./mark_as_failed"
require "./inherit_fields"

abstract class Avram::Form(T)
  include Avram::Validations
  include Avram::NeedyInitializerAndSaveMethods
  include Avram::Virtual
  include Avram::Callbacks
  include Avram::NestedForm
  include Avram::MarkAsFailed
  include Avram::InheritFields

  enum SaveStatus
    Saved
    SaveFailed
    Unperformed
  end

  macro inherited
    @valid : Bool = true
    @save_status = SaveStatus::Unperformed

    @@fillable_param_keys = [] of String
    @@schema_class = T
  end

  property save_status

  @record : T?
  @params : Avram::Paramable
  getter :record, :params

  abstract def table_name
  abstract def fields

  def form_name
    self.class.form_name
  end

  def self.form_name
    self.name.underscore.gsub("_form", "")
  end

  def log_failed_save
    Avram.logger.warn({
      failed_to_save:    self.class.name.to_s,
      validation_errors: error_messages_as_string,
    })
  end

  private def error_messages_as_string
    errors.map do |field_name, messages|
      "#{field_name} #{messages.join(", ")}"
    end.join(". ")
  end

  def errors
    fields.reduce({} of Symbol => Array(String)) do |errors_hash, field|
      if field.errors.empty?
        errors_hash
      else
        errors_hash[field.name] = field.errors
        errors_hash
      end
    end
  end

  def self.save(*args, **named_args, &block)
    {% raise <<-ERROR
      Forms do not have a 'save' method.

      Try this...

        ▸ Use 'create' to create a brand new record.
        ▸ Use 'update' to update an existing record.

      ERROR
    %}
  end

  macro add_fields(primary_key_type, fields)
    {% for field in fields %}
      {% FIELDS << field %}
    {% end %}

    private def extract_changes_from_params
      fillable_params.each do |key, value|
        {% for field in fields %}
          set_{{ field[:name] }}_from_param value if key == {{ field[:name].stringify }}
        {% end %}
      end
    end

    {% for field in fields %}
      @_{{ field[:name] }} : Avram::Field({{ field[:type] }}?)?

      def {{ field[:name] }}
        _{{ field[:name] }}
      end

      def {{ field[:name] }}=(_value)
        \{% raise <<-ERROR
          Can't set a field value with '{{field[:name]}} = '

          Try this...

            ▸ Use '.value' to set the value: '{{field[:name]}}.value = '

          ERROR
          %}
      end

      private def _{{ field[:name] }}
        @_{{ field[:name] }} ||= Avram::Field({{ field[:type] }}?).new(
          name: :{{ field[:name].id }},
          param: fillable_params["{{ field[:name] }}"]?,
          value: @record.try(&.{{ field[:name] }}),
          form_name: form_name)
      end

      def fillable_params
        new_params = {} of String => String
        @params.nested(form_name).each do |key, value|
          new_params[key] = value
        end
        new_params.select(@@fillable_param_keys)
      end

      def set_{{ field[:name] }}_from_param(_value)
        parse_result = {{ field[:type] }}::Lucky.parse(_value)
        if parse_result.is_a? Avram::Type::SuccessfulCast
          {{ field[:name] }}.value = parse_result.value
        else
          {{ field[:name] }}.add_error "is invalid"
        end
      end
    {% end %}

    def fields
      database_fields + virtual_fields
    end

    private def database_fields
      [
        {% for field in fields %}
          {{ field[:name] }},
        {% end %}
      ]
    end

    def required_fields
      Tuple.new(
        {% for field in fields %}
          {% if !field[:nilable] && !field[:autogenerated] %}
            {{ field[:name] }},
          {% end %}
        {% end %}
      )
    end

    def after_prepare
      validate_required *required_fields

      {% if primary_key_type == :uuid %}
        id.value ||= UUID.random()
      {% end %}
    end
  end

  private def ensure_paramable(params)
    if params.is_a? Avram::Paramable
      params
    else
      Avram::Params.new(params)
    end
  end

  def valid? : Bool
    prepare
    after_prepare
    fields.all? &.valid?
  end

  abstract def after_prepare

  def saved?
    save_status == SaveStatus::Saved
  end

  def save_failed?
    save_status == SaveStatus::SaveFailed
  end

  macro allow(*args)
    {% raise "'allow' has been renamed to 'fillable'" %}
  end

  macro fillable(*field_names)
    {% for field_name in field_names %}
      {% if field_name.is_a?(TypeDeclaration) %}
        {% raise <<-ERROR
          Must use a Symbol or a bare word in 'fillable'. Instead, got: #{field_name}

          Try this...

            ▸ fillable #{field_name.var}

          ERROR
        %}
      {% end %}
      {% unless field_name.is_a?(SymbolLiteral) || field_name.is_a?(Call) %}
        {% raise <<-ERROR
          Must use a Symbol or a bare word in 'fillable'. Instead, got: #{field_name}

          Try this...

            ▸ Use a bare word (recommended): 'fillable name'
            ▸ Use a Symbol: 'fillable :name'

          ERROR
        %}
      {% end %}
      {% if FIELDS.any? { |field| field[:name].id == field_name.id } %}
        def {{ field_name.id }}
          _{{ field_name.id }}.fillable
        end

        @@fillable_param_keys << "{{ field_name.id }}"
      {% else %}
        {% raise <<-ERROR
          Can't make '#{field_name}' fillable because the column has not been defined on the model.

          Try this...

            ▸ Make sure you spelled the column correctly.
            ▸ Add the column to the model if it doesn't exist.
            ▸ Use 'virtual' if you want a field that is not saved to the database.

          ERROR
        %}
      {% end %}
    {% end %}
  end

  def changes
    _changes = {} of Symbol => String?
    database_fields.each do |field|
      if field.changed?
        _changes[field.name] = if field.value.nil?
                                 nil
                               else
                                 field.value.to_s
                               end
      end
    end
    _changes
  end

  def save : Bool
    if perform_save
      self.save_status = SaveStatus::Saved
      true
    else
      mark_as_failed
      false
    end
  end

  private def perform_save : Bool
    if valid? && changes.any?
      Avram::Repo.transaction do
        is_update = persisted?
        before_save
        if is_update
          before_update
        else
          before_create
        end

        insert_or_update
        saved_record = record.not_nil!
        after_save(saved_record)

        if is_update
          after_update(saved_record)
        else
          after_create(saved_record)
        end
        true
      end
    else
      valid? && changes.empty?
    end
  end

  def save! : T
    if save
      record.not_nil!
    else
      raise Avram::InvalidFormError(typeof(self)).new(form: self)
    end
  end

  def update! : T
    save!
  end

  def persisted? : Bool
    !!record_id
  end

  private def insert_or_update
    if persisted?
      update record_id
    else
      insert
    end
  end

  private def record_id
    @record.try &.id
  end

  # Default callbacks
  def prepare; end

  def after_prepare; end

  def before_save; end

  def after_save(_record : T); end

  def before_create; end

  def after_create(_record : T); end

  def before_update; end

  def after_update(_record : T); end

  private def insert : T
    self.created_at.value ||= Time.utc_now
    self.updated_at.value ||= Time.utc_now
    @record = Avram::Repo.run do |db|
      db.query insert_sql.statement, insert_sql.args do |rs|
        @record = @@schema_class.from_rs(rs).first
      end
    end
  end

  private def update(id) : T
    self.updated_at.value = Time.utc_now
    @record = Avram::Repo.run do |db|
      db.query update_query(id).statement_for_update(changes), update_query(id).args_for_update(changes) do |rs|
        @record = @@schema_class.from_rs(rs).first
      end
    end
  end

  private def update_query(id)
    Avram::QueryBuilder
      .new(table_name)
      .select(@@schema_class.column_names)
      .where(Avram::Where::Equal.new(:id, id.to_s))
  end

  private def insert_sql
    Avram::Insert.new(table_name, changes, @@schema_class.column_names)
  end
end
